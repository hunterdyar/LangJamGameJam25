{on-spawn
	(set @taking-turn 0)
	(set @board (find-type gameplay))
}

{can-move-to @space
	(print :space)
	(if (gte :space (get-from :g cols)) (return false))
	(if (lt :space 0) (return false))
	(for @i @entity (children :board)
		(print "oh")
		(if (eq (get-from :entity x) :x) (return false))
	)
	(return true)
}

{move-left
	 (if (eq :taking-turn 1) (print "fuck")
	 	[(if (can-move-to (round (sub :x 1)))
			(start-routine
				(set taking-turn 1)
				(set @rx :x)#base x
				(for @t (range 0 (get-from :g scale))
					[
						(set x (sub :rx (ease-in-out (div :t (get-from :g scale)))))
						(yield (seconds (div .5  (get-from :g scale))))
					]
				)
				(set @x (sub :rx 1))
				(set taking-turn 0)
			)
		 ) 
		 (print "cant move")
	  ])
}

{move-right
 (if (eq :taking-turn 1) (print "fuck")
		[(if (can-move-to (round (add :x 1)))
			(start-routine
				(set taking-turn 1)
				(set @rx :x)#base x
				(for @t (range 0 (get-from :g scale))
				[
					(set x (add :rx (ease-in-out (div :t (get-from :g scale)))))
					(yield (seconds (div .5  (get-from :g scale))))
				]
				)
				(set @x (add :rx 1))
				(set taking-turn 0)
			)
		)
		]
	)
}
{move-swap
	(start-routine 
		(if (eq :taking-turn 1) (print "fuck")
			(if (gt :facing 0) (set facing -1) (set facing 1))
		)
	)
}
{move-slash
	# coroutine
	# x+facing
	# grid get entity at ???
	# call health -1
}